Directory Roles
- controllers
    – Here we will put the handlers of our routes. As we’ll see in the routes/ component of the Node.js project, when the client “pings” our routes for the different CRUD operations , we create handlers to represent each one of those operations. In the controllers we use the services’ logic to handle responses to the client. A good naming convention is the entity associated to that specific controller followed by controller (statistics-controller.js, contact-controller.js). 
- data
    – This is a component designed for implementing constants and enumerables. Instead of using strings for data coming from a third party API, e.g. statuses, you can create constants in the data/ folder which you can reuse easily.
- models
    – Every model is an object matching the fields in the table by name and type. They do not make any changes to the data but simply represent it in your codebase. Depending on the ORM you are using, models will be different but you can store them as separate js files – user.js, group.js, etc. 
- routes
    – Everything related to routing belongs here. Routes are the most essential part of an API, so having them well structured will impact the software development life cycle. Remember the “every file has it’s index” earlier? Here we can make the most out of it by defining more abstraction to your routes, specified in separate project components. That makes it easier and cleaner for everyone to understand which routes relate to which entities. A good naming convention is the name of the entity associated to that specific route followed by routes (contact-routes.js, group-routes.js). 
- services
    - The business logic in your application is stored here. These are mostly files exporting classes or a giant function depending on your Node.js project requirements. Essentially, theycontain the more complex functionalities in your codebase. In almost all cases, services and models will relate to one another. For example in services you will use the database tables representation coming from the models as data. This data is the same you implement features in the application with.
    - The service methods are called in the controllers mentioned earlier. It’s a good practice to create a base or a subfolder that will represent the common logic of different services Also, when you have a group of services sharing the same business logic (for example, coming from a third party API), it would be more useful to place them in a subfolder. The two most common naming conventions when it comes to services here are camel case or placing a “.service” at the end of the file name (e.g. statistics.service.js or statisticsService.js and so on).
- utils
    - These are the so-called utility or “pure” functions. You pass them an input and they simply mutate it and return an output. They are called utility because you can use them in multiple parts of your system, regardless of the business logic behind them. Notable examples are date conversion or encryption/ decryption of functions.
